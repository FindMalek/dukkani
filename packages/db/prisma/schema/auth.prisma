/**
 * Represents a user account in the Dukkani platform.
 * Users can own stores, be team members of stores, and have authentication sessions.
 * This is the core user entity for authentication and authorization.
 * **Key Fields:**
 * - `id`: Unique identifier (CUID, mapped to "_id" for Better Auth compatibility)
 * - `name`: User's display name
 * - `email`: User's email address (must be unique)
 * - `emailVerified`: Whether the email has been verified
 * - `image`: Optional profile image URL
 * - `telegramUserName`: Optional Telegram username
 * - `telegramChatId`: Optional Telegram chat ID for notifications
 * - `telegramLinkedAt`: Optional timestamp when Telegram was linked
 * - `onboardingStep`: Optional onboarding step (STORE_SETUP, STORE_CREATED, STORE_CONFIGURED, STORE_LAUNCHED)
 * - `createdAt`: Timestamp when the user was created
 * - `updatedAt`: Timestamp when the user was last updated
 * **Relationships:**
 * - Has many Sessions (authentication sessions)
 * - Has many Accounts (OAuth/credential providers)
 * - Has many Stores (as owner)
 * - Has many TeamMembers (as team member in stores)
 * - Has many TelegramOTPs (OTP codes for linking Telegram)
 * - Has many TelegramDisconnectConfirmations (disconnect confirmation tokens)
 * **Business Logic:**
 * - Email must be unique across all users
 * - Users can own multiple stores
 * - Users can be team members in multiple stores
 * - Authentication is handled through Better Auth library
 */
model User {
  id   String @id @map("_id")
  name String

  email         String
  emailVerified Boolean @map("email_verified")

  image            String? @map("image")
  telegramUserName String? @map("telegram_user_name")
  telegramChatId   String? @unique @map("telegram_chat_id")

  onboardingStep UserOnboardingStep @default(STORE_SETUP) @map("onboarding_step")

  telegramLinkedAt DateTime? @map("telegram_linked_at")
  createdAt        DateTime  @map("created_at")
  updatedAt        DateTime  @map("updated_at")

  sessions                        Session[]
  accounts                        Account[]
  teamMembers                     TeamMember[]
  telegramOTPs                    TelegramOTP[]
  stores                          Store[]                          @relation("StoreOwner")
  telegramDisconnectConfirmations TelegramDisconnectConfirmation[]

  @@unique([email])
  @@map("users")
}

/**
 * Represents an active authentication session for a user.
 * Sessions track user login state and include security metadata like IP address and user agent.
 * Sessions expire after a set time and can be invalidated.
 * **Key Fields:**
 * - `id`: Unique identifier (CUID, mapped to "_id" for Better Auth compatibility)
 * - `expiresAt`: Timestamp when the session expires
 * - `token`: Unique session token (must be unique)
 * - `userId`: Reference to the User this session belongs to
 * - `ipAddress`: Optional IP address where session was created
 * - `userAgent`: Optional browser/client user agent string
 * - `createdAt`: Timestamp when the session was created
 * - `updatedAt`: Timestamp when the session was last updated
 * **Relationships:**
 * - Belongs to one User
 * **Business Logic:**
 * - Each session token must be unique
 * - Sessions are used for authentication and authorization
 * - When a user is deleted, all their sessions are cascade deleted
 * - IP and user agent help with security monitoring
 */
model Session {
  id String @id @map("_id")

  token String

  ipAddress String? @map("ip_address")
  userAgent String? @map("user_agent")

  expiresAt DateTime @map("expires_at")
  createdAt DateTime @map("created_at")
  updatedAt DateTime @map("updated_at")

  userId String @map("user_id")
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([token])
  @@map("sessions")
}

/**
 * Represents an authentication account linked to a user.
 * Supports multiple authentication providers (OAuth, email/password, etc.).
 * Stores provider-specific tokens and credentials.
 * **Key Fields:**
 * - `id`: Unique identifier (CUID, mapped to "_id" for Better Auth compatibility)
 * - `accountId`: Provider-specific account identifier
 * - `providerId`: Authentication provider (e.g., "google", "github", "credentials")
 * - `userId`: Reference to the User this account belongs to
 * - `accessToken`: Optional OAuth access token
 * - `refreshToken`: Optional OAuth refresh token
 * - `idToken`: Optional OAuth ID token
 * - `accessTokenExpiresAt`: Optional expiration for access token
 * - `refreshTokenExpiresAt`: Optional expiration for refresh token
 * - `scope`: Optional OAuth scope string
 * - `password`: Optional hashed password (for credential provider)
 * - `createdAt`: Timestamp when the account was created
 * - `updatedAt`: Timestamp when the account was last updated
 * **Relationships:**
 * - Belongs to one User
 * **Business Logic:**
 * - A user can have multiple accounts (different providers)
 * - OAuth tokens are stored securely and can expire
 * - Password is hashed and stored only for credential-based authentication
 * - When a user is deleted, all their accounts are cascade deleted
 */
model Account {
  id String @id @map("_id")

  accountId  String @map("account_id")
  providerId String @map("provider_id")

  scope    String?
  password String?

  accessToken  String? @map("access_token")
  refreshToken String? @map("refresh_token")
  idToken      String? @map("id_token")

  accessTokenExpiresAt  DateTime? @map("access_token_expires_at")
  refreshTokenExpiresAt DateTime? @map("refresh_token_expires_at")

  createdAt DateTime @map("created_at")
  updatedAt DateTime @map("updated_at")

  userId String @map("user_id")
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("accounts")
}

/**
 * Represents a verification token or code.
 * Used for email verification, password reset, and other verification flows.
 * Tokens expire after a set time for security.
 * **Key Fields:**
 * - `id`: Unique identifier (CUID, mapped to "_id" for Better Auth compatibility)
 * - `identifier`: What is being verified (e.g., email address)
 * - `value`: The verification token or code
 * - `expiresAt`: Timestamp when the verification expires
 * - `createdAt`: Optional timestamp when the verification was created
 * - `updatedAt`: Optional timestamp when the verification was last updated
 * **Business Logic:**
 * - Verification tokens are time-limited for security
 * - Used for email verification, password resets, etc.
 * - Tokens should be single-use and invalidated after use
 * - Expiration prevents stale verification attempts
 */
model Verification {
  id String @id @map("_id")

  identifier String
  value      String

  expiresAt DateTime  @map("expires_at")
  createdAt DateTime? @map("created_at")
  updatedAt DateTime? @map("updated_at")

  @@map("verifications")
}
