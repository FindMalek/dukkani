/**
 * Represents a customer order placed in a store.
 * Orders contain customer information, delivery address, status tracking, and multiple order items.
 * Each order has a custom ID format: {STORE_PREFIX}-{RANDOM} (e.g., "AHM-abc12345").
 * **Key Fields:**
 * - `id`: Custom string ID with store prefix (e.g., "AHM-abc12345")
 * - `status`: Current order status (PENDING, CONFIRMED, PROCESSING, SHIPPED, DELIVERED, CANCELLED)
 * - `paymentMethod`: Payment method used for the order (COD, CARD)
 * - `isWhatsApp`: Whether customer wants to receive order updates via WhatsApp for this order
 * - `notes`: Optional special instructions or notes
 * - `storeId`: Reference to the Store where the order was placed
 * - `customerId`: Reference to a registered Customer (required - all orders now have customers)
 * - `addressId`: Reference to the delivery Address for this order
 * - `variantId`: Optional reference to a ProductVariant (null for products without variants) * - `createdAt`: Timestamp when the order was created
 * - `updatedAt`: Timestamp when the order was last updated
 * **Relationships:**
 * - Belongs to one Store
 * - Belongs to one Customer (all orders are linked to customers)
 * - Optionally belongs to one Address (delivery address)
 * - Optionally belongs to one ProductVariant (variant of a product)
 * - Has many OrderItems (products in the order)
 * - Has many WhatsAppMessages (communication history)
 * **Business Logic:**
 * - All orders are now linked to Customer records (no more guest orders)
 * - Customers with orders cannot be deleted (Restrict) to maintain data integrity
 * - Order status tracks the fulfillment lifecycle
 * - Custom ID format makes orders URL-friendly and identifiable by store
 * - Address is stored separately in Address model for reuse across orders
 */
model Order {
  id String @id

  status OrderStatus

  paymentMethod PaymentMethod @default(COD) @map("payment_method")

  isWhatsApp Boolean @default(false) @map("is_whatsapp")

  notes String?

  orderItems       OrderItem[]
  whatsappMessages WhatsAppMessage[]

  updatedAt DateTime @updatedAt @map("updated_at")
  createdAt DateTime @default(now()) @map("created_at")

  storeId String @map("store_id")
  store   Store  @relation(fields: [storeId], references: [id], onDelete: Cascade)

  customerId String   @map("customer_id")
  customer   Customer @relation(fields: [customerId], references: [id], onDelete: Restrict)

  addressId String?  @map("address_id")
  address   Address? @relation(fields: [addressId], references: [id], onDelete: SetNull)

  variantId String?         @map("variant_id")
  variant   ProductVariant? @relation(fields: [variantId], references: [id], onDelete: SetNull)

  @@map("orders")
}

/**
 * Represents a single product item within an order.
 * Each order can contain multiple order items, each referencing a specific product with quantity and price.
 * The price is stored at order time to preserve historical pricing even if product prices change.
 * **Key Fields:**
 * - `id`: Unique identifier (CUID)
 * - `orderId`: Reference to the parent Order
 * - `productId`: Reference to the Product being ordered
 * - `quantity`: Number of units ordered
 * - `price`: Price per unit at the time of order (stored as Decimal for accuracy)
 * - `createdAt`: Timestamp when the order item was created
 * - `updatedAt`: Timestamp when the order item was last updated
 * **Relationships:**
 * - Belongs to one Order
 * - Belongs to one Product
 * **Business Logic:**
 * - Price is captured at order time to maintain historical accuracy
 * - When an order is deleted, all its order items are cascade deleted
 * - Quantity must be positive
 */
model OrderItem {
  id String @id @default(cuid())

  orderId   String @map("order_id")
  productId String @map("product_id")

  quantity Int
  price    Decimal @db.Decimal(10, 2)

  updatedAt DateTime @updatedAt @map("updated_at")
  createdAt DateTime @default(now()) @map("created_at")

  order            Order           @relation(fields: [orderId], references: [id], onDelete: Cascade)
  product          Product         @relation(fields: [productId], references: [id], onDelete: Cascade)
  productVariant   ProductVariant? @relation(fields: [productVariantId], references: [id])
  productVariantId String?

  @@map("order_items")
}
