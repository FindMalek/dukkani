/**
 * Represents a store in the Dukkani platform.
 * Each store is owned by a user and can have products, orders, team members, and customers.
 * Stores have customizable themes, categories, and subscription plans that control their features and limits.
 * **Key Fields:**
 * - `id`: Unique identifier (CUID)
 * - `slug`: URL-friendly unique identifier for the store (e.g., "ahmed-fashion")
 * - `name`: Display name of the store
 * - `description`: Optional description of the store
 * - `whatsappNumber`: Optional WhatsApp number for customer communication
 * - `theme`: Visual theme for the store (LIGHT, DARK, MINIMAL, MODERN, CLASSIC)
 * - `category`: Store category (FASHION, ELECTRONICS, FOOD, HOME, BEAUTY, SPORTS, BOOKS, TOYS, OTHER)
 * - `notificationMethod`: Notification method for the store (EMAIL, TELEGRAM, BOTH)
 * - `supportedPaymentMethods`: Array of payment methods the store accepts (COD, CARD)
 * - `status`: Status of the store (DRAFT, PUBLISHED, SUSPENDED, ARCHIVED)
 * - `ownerId`: Reference to the User who owns this store
 * - `createdAt`: Timestamp when the store was created
 * - `updatedAt`: Timestamp when the store was last updated
 * **Relationships:**
 * - Belongs to one User (owner)
 * - Has one StorePlan (subscription plan)
 * - Has many Products
 * - Has many Orders
 * - Has many TeamMembers (staff/employees)
 * - Has many Customers
 * - Has many SalesMetrics (daily sales data)
 * **Business Logic:**
 * - Each store must have a unique slug for URL routing
 * - When the owner is deleted, the store is cascade deleted
 * - Store plans control order limits and feature access
 */
model Store {
  id   String @id @default(cuid())
  slug String @unique

  name           String
  description    String?
  whatsappNumber String? @map("whatsapp_number")

  storePlan StorePlan?
  theme     StoreTheme?
  category  StoreCategory?

  status                  StoreStatus              @default(DRAFT)
  notificationMethod      StoreNotificationMethod? @default(EMAIL) @map("notification_method")
  supportedPaymentMethods PaymentMethod[]          @default([COD]) @map("supported_payment_methods")

  orders              Order[]
  products            Product[]
  categories          Category[]
  customers           Customer[]
  collections         Collection[]
  teamMembers         TeamMember[]
  salesMetrics        SalesMetric[]
  launchNotifications LaunchNotification[]

  updatedAt DateTime @updatedAt @map("updated_at")
  createdAt DateTime @default(now()) @map("created_at")

  ownerId String @map("owner_id")
  owner   User   @relation("StoreOwner", fields: [ownerId], references: [id], onDelete: Cascade)

  @@map("stores")
}

/**
 * Represents a subscription plan for a store.
 * Each store has one plan that defines its order limits, features, and billing tier.
 * Plans can be FREE, BASIC, PREMIUM, or ENTERPRISE with different order limits.
 * **Key Fields:**
 * - `id`: Unique identifier (CUID)
 * - `storeId`: Reference to the Store this plan belongs to (one-to-one relationship)
 * - `planType`: Type of plan (FREE, BASIC, PREMIUM, ENTERPRISE)
 * - `orderLimit`: Maximum number of orders allowed in the current period
 * - `orderCount`: Current number of orders in the period (resets based on plan cycle)
 * - `resetAt`: Optional timestamp when the order count should reset
 * - `createdAt`: Timestamp when the plan was created
 * - `updatedAt`: Timestamp when the plan was last updated
 * **Relationships:**
 * - Belongs to one Store (one-to-one, unique constraint)
 * **Business Logic:**
 * - Each store must have exactly one plan
 * - Order count tracks usage against the limit
 * - Reset date can be used for monthly/annual billing cycles
 * - When store is deleted, plan is cascade deleted
 */
model StorePlan {
  id String @id @default(cuid())

  planType StorePlanType @map("plan_type")

  orderLimit Int @map("order_limit")
  orderCount Int @default(0) @map("order_count")

  resetAt   DateTime? @map("reset_at")
  updatedAt DateTime  @updatedAt @map("updated_at")
  createdAt DateTime  @default(now()) @map("created_at")

  storeId String @unique @map("store_id")
  store   Store  @relation(fields: [storeId], references: [id], onDelete: Cascade)

  @@map("store_plans")
}

/**
 * Represents a launch notification subscription for a store.
 * Customers can subscribe to be notified when a DRAFT store goes live.
 * **Key Fields:**
 * - `id`: Unique identifier (CUID)
 * - `storeId`: Reference to the Store
 * - `email`: Optional email address
 * - `phone`: Optional phone number
 * - `notified`: Whether the subscriber has been notified
 * - `notifiedAt`: Timestamp when notification was sent
 * - `createdAt`: Timestamp when subscription was created
 * **Business Logic:**
 * - Either email or phone must be provided (not both required, but at least one)
 * - When store status changes from DRAFT to PUBLISHED, all subscribers should be notified
 * - Prevents duplicate subscriptions (same email/phone for same store)
 */
model LaunchNotification {
  id String @id @default(cuid())

  email String?
  phone String?

  notified   Boolean   @default(false)
  notifiedAt DateTime? @map("notified_at")

  storeId String @map("store_id")
  store   Store  @relation(fields: [storeId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now()) @map("created_at")

  @@unique([storeId, email])
  @@unique([storeId, phone])
  @@index([storeId])
  @@index([storeId, notified])
  @@map("launch_notifications")
}
