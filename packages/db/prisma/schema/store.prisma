/**
 * Represents a store in the Dukkani platform.
 * Each store is owned by a user and can have products, orders, team members, and customers.
 * Stores have customizable themes, categories, and subscription plans that control their features and limits.
 * **Key Fields:**
 * - `id`: Unique identifier (CUID)
 * - `slug`: URL-friendly unique identifier for the store (e.g., "ahmed-fashion")
 * - `name`: Display name of the store
 * - `description`: Optional description of the store
 * - `whatsappNumber`: Optional WhatsApp number for customer communication
 * - `theme`: Visual theme for the store (LIGHT, DARK, MINIMAL, MODERN, CLASSIC)
 * - `category`: Store category (FASHION, ELECTRONICS, FOOD, HOME, BEAUTY, SPORTS, BOOKS, TOYS, OTHER)
 * - `notificationMethod`: Notification method for the store (EMAIL, TELEGRAM, BOTH)
 * - `ownerId`: Reference to the User who owns this store
 * - `createdAt`: Timestamp when the store was created
 * - `updatedAt`: Timestamp when the store was last updated
 * **Relationships:**
 * - Belongs to one User (owner)
 * - Has one StorePlan (subscription plan)
 * - Has many Products
 * - Has many Orders
 * - Has many TeamMembers (staff/employees)
 * - Has many Customers
 * - Has many SalesMetrics (daily sales data)
 * **Business Logic:**
 * - Each store must have a unique slug for URL routing
 * - When the owner is deleted, the store is cascade deleted
 * - Store plans control order limits and feature access
 */
model Store {
  id   String @id @default(cuid())
  slug String @unique

  name           String
  description    String?
  whatsappNumber String? @map("whatsapp_number")

  storePlan          StorePlan?
  theme              StoreTheme?
  category           StoreCategory?
  notificationMethod StoreNotificationMethod? @default(EMAIL) @map("notification_method")

  orders       Order[]
  products     Product[]
  customers    Customer[]
  teamMembers  TeamMember[]
  salesMetrics SalesMetric[]

  updatedAt DateTime @updatedAt @map("updated_at")
  createdAt DateTime @default(now()) @map("created_at")

  ownerId String @map("owner_id")
  owner   User   @relation("StoreOwner", fields: [ownerId], references: [id], onDelete: Cascade)

  @@map("stores")
}

/**
 * Represents a subscription plan for a store.
 * Each store has one plan that defines its order limits, features, and billing tier.
 * Plans can be FREE, BASIC, PREMIUM, or ENTERPRISE with different order limits.
 * **Key Fields:**
 * - `id`: Unique identifier (CUID)
 * - `storeId`: Reference to the Store this plan belongs to (one-to-one relationship)
 * - `planType`: Type of plan (FREE, BASIC, PREMIUM, ENTERPRISE)
 * - `orderLimit`: Maximum number of orders allowed in the current period
 * - `orderCount`: Current number of orders in the period (resets based on plan cycle)
 * - `resetAt`: Optional timestamp when the order count should reset
 * - `createdAt`: Timestamp when the plan was created
 * - `updatedAt`: Timestamp when the plan was last updated
 * **Relationships:**
 * - Belongs to one Store (one-to-one, unique constraint)
 * **Business Logic:**
 * - Each store must have exactly one plan
 * - Order count tracks usage against the limit
 * - Reset date can be used for monthly/annual billing cycles
 * - When store is deleted, plan is cascade deleted
 */
model StorePlan {
  id String @id @default(cuid())

  planType   StorePlanType @map("plan_type")
  
  orderLimit Int           @map("order_limit")
  orderCount Int           @default(0) @map("order_count")

  resetAt   DateTime? @map("reset_at")
  updatedAt DateTime  @updatedAt @map("updated_at")
  createdAt DateTime  @default(now()) @map("created_at")

  storeId String @unique @map("store_id")
  store   Store  @relation(fields: [storeId], references: [id], onDelete: Cascade)

  @@map("store_plans")
}